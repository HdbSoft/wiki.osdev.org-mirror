<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>UEFI - OSDev Wiki</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.18.0" />
<link rel="canonical" href="UEFI" />
<link rel="shortcut icon" href="favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.osdev.org/opensearch_desc.php" title="OSDev Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.osdev.org/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="http://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.osdev.org/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.osdev.org/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: wikidb:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */
</style>
<script src="http://wiki.osdev.org/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "UEFI", "wgTitle": "UEFI", "wgCurRevisionId": 22092, "wgArticleId": 2924, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["X86", "X86-64", "IA-64", "ARM", "Firmware", "UEFI"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "http://wiki.osdev.org/index.php?title=MediaWiki:Geshi.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-bash {line-height: normal;}
.source-bash li, .source-bash pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for bash
 * CSS class: source-bash, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.bash.source-bash .de1, .bash.source-bash .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.bash.source-bash  {font-family:monospace;}
.bash.source-bash .imp {font-weight: bold; color: red;}
.bash.source-bash li, .bash.source-bash .li1 {font-weight: normal; vertical-align:top;}
.bash.source-bash .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.bash.source-bash .li2 {font-weight: bold; vertical-align:top;}
.bash.source-bash .kw1 {color: #000000; font-weight: bold;}
.bash.source-bash .kw2 {color: #c20cb9; font-weight: bold;}
.bash.source-bash .kw3 {color: #7a0874; font-weight: bold;}
.bash.source-bash .co0 {color: #666666; font-style: italic;}
.bash.source-bash .co1 {color: #800000;}
.bash.source-bash .co2 {color: #cc0000; font-style: italic;}
.bash.source-bash .co3 {color: #000000; font-weight: bold;}
.bash.source-bash .co4 {color: #666666;}
.bash.source-bash .es1 {color: #000099; font-weight: bold;}
.bash.source-bash .es2 {color: #007800;}
.bash.source-bash .es3 {color: #007800;}
.bash.source-bash .es4 {color: #007800;}
.bash.source-bash .es5 {color: #780078;}
.bash.source-bash .es_h {color: #000099; font-weight: bold;}
.bash.source-bash .br0 {color: #7a0874; font-weight: bold;}
.bash.source-bash .sy0 {color: #000000; font-weight: bold;}
.bash.source-bash .st0 {color: #ff0000;}
.bash.source-bash .st_h {color: #ff0000;}
.bash.source-bash .nu0 {color: #000000;}
.bash.source-bash .re0 {color: #007800;}
.bash.source-bash .re1 {color: #007800;}
.bash.source-bash .re2 {color: #007800;}
.bash.source-bash .re4 {color: #007800;}
.bash.source-bash .re5 {color: #660033;}
.bash.source-bash .ln-xtra, .bash.source-bash li.ln-xtra, .bash.source-bash div.ln-xtra {background-color: #ffc;}
.bash.source-bash span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "http://wiki.osdev.org/index.php?title=MediaWiki:Geshi.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-asm {line-height: normal;}
.source-asm li, .source-asm pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for asm
 * CSS class: source-asm, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.asm.source-asm .de1, .asm.source-asm .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.asm.source-asm  {font-family:monospace;}
.asm.source-asm .imp {font-weight: bold; color: red;}
.asm.source-asm li, .asm.source-asm .li1 {font-weight: normal; vertical-align:top;}
.asm.source-asm .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.asm.source-asm .li2 {font-weight: bold; vertical-align:top;}
.asm.source-asm .kw1 {color: #00007f; font-weight: bold;}
.asm.source-asm .kw2 {color: #0000ff; font-weight: bold;}
.asm.source-asm .kw3 {color: #00007f;}
.asm.source-asm .kw4 {color: #000000; font-weight: bold;}
.asm.source-asm .kw5 {color: #000000; font-weight: bold;}
.asm.source-asm .co1 {color: #666666; font-style: italic;}
.asm.source-asm .co2 {color: #adadad; font-style: italic;}
.asm.source-asm .es0 {color: #000099; font-weight: bold;}
.asm.source-asm .br0 {color: #009900; font-weight: bold;}
.asm.source-asm .sy0 {color: #339933;}
.asm.source-asm .st0 {color: #7f007f;}
.asm.source-asm .nu0 {color: #0000ff;}
.asm.source-asm .ln-xtra, .asm.source-asm li.ln-xtra, .asm.source-asm div.ln-xtra {background-color: #ffc;}
.asm.source-asm span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "http://wiki.osdev.org/index.php?title=MediaWiki:Geshi.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-UEFI action-view skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">UEFI</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From OSDev Wiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub">(Redirected from <a href="http://wiki.osdev.org/index.php?title=EFI&amp;redirect=no" title="EFI">EFI</a>)</div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to: <a href="EFI#mw-head">navigation</a>,
					<a href="EFI#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div lang="en" dir="ltr" class="mw-content-ltr"><p>(U)EFI or (Unified) Extensible Firmware Interface is a specification for x86, x86-64, ARM, and Itanium platforms that defines a software interface between the operating system and the platform firmware/BIOS. The original EFI was developed in the mid-1990s by Intel for use developing firmware/BIOS for Itanium platforms. In 2005 Intel transitioned the specification to a new working group called the Unified EFI Forum, consisting of companies such as AMD, Microsoft, Apple, and Intel itself. All modern PCs ship with UEFI firmware and UEFI is widely supported by both commercial and open source operating systems. Backwards compatibility is provided for legacy operating systems.
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="EFI#UEFI_basics"><span class="tocnumber">1</span> <span class="toctext">UEFI basics</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="EFI#UEFI_vs._legacy_BIOS"><span class="tocnumber">1.1</span> <span class="toctext">UEFI vs. legacy BIOS</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="EFI#Platform_initialization"><span class="tocnumber">1.1.1</span> <span class="toctext">Platform initialization</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="EFI#Boot_mechanism"><span class="tocnumber">1.1.2</span> <span class="toctext">Boot mechanism</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="EFI#System_discovery"><span class="tocnumber">1.1.3</span> <span class="toctext">System discovery</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="EFI#Convenience_functions"><span class="tocnumber">1.1.4</span> <span class="toctext">Convenience functions</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="EFI#Development_environment"><span class="tocnumber">1.1.5</span> <span class="toctext">Development environment</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="EFI#Emulation"><span class="tocnumber">1.1.6</span> <span class="toctext">Emulation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="EFI#Legacy_bootloader_or_UEFI_application.3F"><span class="tocnumber">1.2</span> <span class="toctext">Legacy bootloader or UEFI application?</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="EFI#UEFI_class_0-3_and_CSM"><span class="tocnumber">1.3</span> <span class="toctext">UEFI class 0-3 and CSM</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="EFI#Secure_Boot"><span class="tocnumber">1.4</span> <span class="toctext">Secure Boot</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="EFI#How_to_use_UEFI"><span class="tocnumber">1.5</span> <span class="toctext">How to use UEFI</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="EFI#Developing_with_GNU-EFI"><span class="tocnumber">2</span> <span class="toctext">Developing with GNU-EFI</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="EFI#Emulation_with_QEMU_and_OVMF"><span class="tocnumber">3</span> <span class="toctext">Emulation with QEMU and OVMF</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="EFI#Creating_disk_images"><span class="tocnumber">3.1</span> <span class="toctext">Creating disk images</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="EFI#Linux.2C_root_required"><span class="tocnumber">3.1.1</span> <span class="toctext">Linux, root required</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="EFI#Linux.2C_root_not_required"><span class="tocnumber">3.1.2</span> <span class="toctext">Linux, root not required</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="EFI#FreeBSD.2C_root_required"><span class="tocnumber">3.1.3</span> <span class="toctext">FreeBSD, root required</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="EFI#Mac_OS_.28root_not_required.29"><span class="tocnumber">3.1.4</span> <span class="toctext">Mac OS (root not required)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-20"><a href="EFI#Launching_UEFI_applications"><span class="tocnumber">3.2</span> <span class="toctext">Launching UEFI applications</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="EFI#Debugging"><span class="tocnumber">3.3</span> <span class="toctext">Debugging</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="EFI#Running_on_real_hardware"><span class="tocnumber">4</span> <span class="toctext">Running on real hardware</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="EFI#NVRAM_variables"><span class="tocnumber">4.1</span> <span class="toctext">NVRAM variables</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="EFI#Bootable_UEFI_applications"><span class="tocnumber">4.2</span> <span class="toctext">Bootable UEFI applications</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="EFI#Exposed_functionality"><span class="tocnumber">4.3</span> <span class="toctext">Exposed functionality</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="EFI#PC_firmware_developers"><span class="tocnumber">4.4</span> <span class="toctext">PC firmware developers</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="EFI#Apple_systems"><span class="tocnumber">4.5</span> <span class="toctext">Apple systems</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-28"><a href="EFI#UEFI_applications_in_detail"><span class="tocnumber">5</span> <span class="toctext">UEFI applications in detail</span></a>
<ul>
<li class="toclevel-2 tocsection-29"><a href="EFI#Binary_Format"><span class="tocnumber">5.1</span> <span class="toctext">Binary Format</span></a>
<ul>
<li class="toclevel-3 tocsection-30"><a href="EFI#Initialization"><span class="tocnumber">5.1.1</span> <span class="toctext">Initialization</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="EFI#Memory"><span class="tocnumber">5.1.2</span> <span class="toctext">Memory</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-32"><a href="EFI#Calling_Conventions"><span class="tocnumber">5.2</span> <span class="toctext">Calling Conventions</span></a>
<ul>
<li class="toclevel-3 tocsection-33"><a href="EFI#GNU-EFI_and_GCC"><span class="tocnumber">5.2.1</span> <span class="toctext">GNU-EFI and GCC</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="EFI#Language_binding"><span class="tocnumber">5.3</span> <span class="toctext">Language binding</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="EFI#EFI_Byte_Code"><span class="tocnumber">5.4</span> <span class="toctext">EFI Byte Code</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="EFI#Common_Problems"><span class="tocnumber">6</span> <span class="toctext">Common Problems</span></a>
<ul>
<li class="toclevel-2 tocsection-37"><a href="EFI#My_UEFI_application_hangs.2Fresets_after_about_5_minutes"><span class="tocnumber">6.1</span> <span class="toctext">My UEFI application hangs/resets after about 5 minutes</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="EFI#My_bootloader_hangs_if_I_use_user_defined_EFI_MEMORY_TYPE_values"><span class="tocnumber">6.2</span> <span class="toctext">My bootloader hangs if I use user defined EFI_MEMORY_TYPE values</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-39"><a href="EFI#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a>
<ul>
<li class="toclevel-2 tocsection-40"><a href="EFI#OSDEV"><span class="tocnumber">7.1</span> <span class="toctext">OSDEV</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="EFI#Wikipedia"><span class="tocnumber">7.2</span> <span class="toctext">Wikipedia</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="EFI#External_Links"><span class="tocnumber">7.3</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="UEFI_basics"> UEFI basics </span></h2>
<h3> <span class="mw-headline" id="UEFI_vs._legacy_BIOS">UEFI vs. legacy BIOS</span></h3>
<p>A common misconception is that UEFI is a replacement for BIOS. In reality, both legacy motherboards and UEFI-based motherboards come with BIOS ROMs, which contain firmware that performs the initial power-on configuration of the system before loading some third-party code into memory and jumping to it. The differences between legacy BIOS firmware and UEFI BIOS firmware are where they find that code, how they prepare the system before jumping to it, and what convenience functions they provide for the code to call while running.
</p>
<h4> <span class="mw-headline" id="Platform_initialization">Platform initialization</span></h4>
<p>On a legacy system, BIOS performs all the usual platform initialization (memory controller configuration, PCI bus configuration and BAR mapping, graphics card initialization, etc.), but then drops into a backwards-compatible real mode environment. The bootloader must enable the A20 gate, configure a GDT and an IDT, switch to protected mode, and for x86-64 CPUs, configure paging and switch to long mode.
</p><p>UEFI firmware performs those same steps, but also prepares a protected mode environment with flat segmentation and for x86-64 CPUs, a long mode environment with identity-mapped paging. The A20 gate is enabled as well.
</p><p>Additionally, the platform initialization procedure of UEFI firmware is standardized. This allows UEFI firmware to be extended in a vendor-neutral way.
</p>
<h4> <span class="mw-headline" id="Boot_mechanism">Boot mechanism</span></h4>
<p>A legacy BIOS loads a 512 byte flat binary blob from the MBR of the boot device into memory at physical address 7C00 and jumps to it. The bootloader cannot return back to BIOS. UEFI firmware loads an arbitrary sized UEFI application (a relocatable PE executable file) from a FAT partition on a GPT-partitioned boot device to some address selected at run-time. Then it calls that application's main entry point. The application can return control to the firmware, which will continue searching for another boot device or bring up a diagnostic menu.
</p>
<h4> <span class="mw-headline" id="System_discovery">System discovery</span></h4>
<p>A legacy bootloader scans memory for structures like the <a href="EBDA" title="EBDA" class="mw-redirect">EBDA</a>, <a href="SMBIOS" title="SMBIOS" class="mw-redirect">SMBIOS</a>, and <a href="ACPI" title="ACPI">ACPI</a> tables. It uses PIO to talk to the root <a href="PCI" title="PCI">PCI</a> controller and scan the PCI bus. It is possible that redundant tables may be present in memory (for example, the <a href="http://wiki.osdev.org/index.php?title=MP&amp;action=edit&amp;redlink=1" class="new" title="MP (page does not exist)">MP</a> table in the SMBIOS contains information that's also present in the ACPI <a href="DSDT" title="DSDT">DSDT</a>) and the bootloader can choose which to use.
</p><p>When UEFI firmware calls a UEFI application's entry point function, it passes a "System Table" structure, which contains pointers to all of the system's ACPI tables, memory map, and other information relevant to an OS. Legacy tables (like SMBIOS) may not be present in memory.
</p>
<h4> <span class="mw-headline" id="Convenience_functions">Convenience functions</span></h4>
<p>A legacy BIOS hooks a variety of interrupts which a bootloader can trigger to access system resources like disks and the screen. These interrupts are not standardized, except by historical convention. Each interrupt uses a different register passing convention.
</p><p>UEFI firmware establishes many callable functions in memory, which are grouped into sets called "protocols" and are discoverable through the System Table. The behavior of each function in each protocol is defined by specification. UEFI applications can define their own protocols and persist them in memory for other UEFI applications to use. Functions are called with a standardized, modern calling convention supported by many C compilers.
</p>
<h4> <span class="mw-headline" id="Development_environment">Development environment</span></h4>
<p>Legacy bootloaders can be developed in any environment that can generate flat binary images: NASM, GCC, etc. UEFI applications can be developed in any language that can be compiled and linked into a <a href="PE" title="PE">PE</a> executable file and supports the calling convention used to access functions established in memory by the UEFI firmware. In practice this means one of two development environments: Intel's TianoCore EDK2 or GNU-EFI.
</p><p><a href="http://wiki.osdev.org/index.php?title=TianoCore&amp;action=edit&amp;redlink=1" class="new" title="TianoCore (page does not exist)">TianoCore</a> is a large, complex environment with its own build system. It can be configured to use GCC, MinGW, Microsoft Visual C++, etc. as a cross-compiler. Not only can it be used to compile UEFI applications, but it can also be used to compile UEFI firmware to be flashed to a BIOS ROM.
</p><p><a href="http://wiki.osdev.org/index.php?title=GNU-EFI&amp;action=edit&amp;redlink=1" class="new" title="GNU-EFI (page does not exist)">GNU-EFI</a> is a set of libraries and headers for compiling UEFI applications with a system's native GCC. It can't be used to compile UEFI firmware. Since it's just a couple of libraries against which a UEFI application can be linked, it is much easier to use than TianoCore.
</p>
<h4> <span class="mw-headline" id="Emulation">Emulation</span></h4>
<p><a href="Bochs" title="Bochs">Bochs</a> ships with a default open-source legacy BIOS. Additionally, <a href="http://wiki.osdev.org/index.php?title=SeaBIOS&amp;action=edit&amp;redlink=1" class="new" title="SeaBIOS (page does not exist)">SeaBIOS</a>, a popular open-source legacy BIOS, has been ported to both the Bochs and <a href="QEMU" title="QEMU">QEMU</a> emulated machines. Both of these BIOSs implement most of the legacy BIOS features you would expect. However, they vary quite significantly in operation from commercial legacy BIOSs on real machines.
</p><p><a href="http://wiki.osdev.org/index.php?title=OVMF&amp;action=edit&amp;redlink=1" class="new" title="OVMF (page does not exist)">OVMF</a>, a popular open source UEFI firmware, has been ported to the QEMU (but not Bochs) emulated machine. Because it implements the UEFI specification, it behaves very similarly to commercial UEFI firmware on real machines. (OVMF itself is built with TianoCore, but pre-built images are available.)
</p>
<h3> <span class="mw-headline" id="Legacy_bootloader_or_UEFI_application.3F">Legacy bootloader or UEFI application?</span></h3>
<p>If you are targeting legacy systems for which UEFI is not available or is not reliable, you should develop a legacy bootloader. This requires intimate knowledge of 16-bit addressing and the backwards-compatibility features of an x86 or x86-64 CPU.  If you are targeting modern systems you should develop a UEFI application. Many UEFI firmwares can be configured to emulate a legacy BIOS, but there is even more variation among these emulated environments than among real legacy BIOS.
</p><p>Although there is a slight learning curve to become familiar with the UEFI development environments, using the System Table, and accessing UEFI-provided protocols (functions), there are far fewer "gotchas" than trying to remain compatible with the wide variety of quickly-becoming-obsolete legacy BIOSs on real machines. UEFI is the standard for all modern PCs.
</p>
<h3> <span class="mw-headline" id="UEFI_class_0-3_and_CSM">UEFI class 0-3 and CSM</span></h3>
<p>PCs are categorized as UEFI class 0, 1, 2, or 3. A class 0 machine is a legacy system with a legacy BIOS; i.e. not a UEFI system at all.
</p><p>A class 1 machine is a UEFI system that runs exclusively in Compatibility Support Module (CSM) mode. CSM is a specification for how UEFI firmware can emulate a legacy BIOS. UEFI firmware in CSM mode loads legacy bootloaders. A class 1 UEFI system may not advertise UEFI support at all, since it isn't exposed to the bootloader. It's only UEFI "within" the BIOS.
</p><p>A class 2 machine is a UEFI system that can launch UEFI applications but also includes the option to run in CSM mode. The majority of modern PCs are UEFI class 2 machines. Sometimes the choice to run UEFI applications vs. CSM is a one-or-the-other setting in the BIOS configuration, and other times the BIOS will decide which to use after selecting the boot device and checking whether it has a legacy bootloader or a UEFI application.
</p><p>A class 3 machine is a UEFI system that does not support CSM. UEFI class 3 machines only run UEFI applications and do not implement CSM for backwards compatibility with legacy bootloaders.
</p>
<h3> <span class="mw-headline" id="Secure_Boot">Secure Boot</span></h3>
<p>Secure Boot is a digital signature scheme for UEFI applications that consists of four components:
</p>
<ul><li> <b>PK</b>: Platform Key
</li><li> <b>KEK</b>: Key Exchange Keys
</li><li> <b>db</b>: Whitelist database
</li><li> <b>dbx</b>: Blacklist database
</li></ul>
<p>UEFI firmware that supports Secure Boot is always in one of three states:
</p>
<ul><li> Setup mode, Secure Boot <i>off</i>
</li><li> User mode, Secure Boot <i>off</i>
</li><li> User mode, Secure Boot <i>on</i>
</li></ul>
<p>In setup mode, any UEFI application can change or delete the PK, add/remove keys from the KEK, and add/remove whitelist or blacklist entries from the db or dbx.
</p><p>In user mode, regardless of whether Secure Boot is on or off:
</p>
<ul><li> The PK may only be changed or deleted by a UEFI application that already has the current PK.
</li><li> Keys can only be added/removed from the KEK by a UEFI application that has the PK.
</li><li> Whitelist and blacklist entries can only be added/removed from the db and dbx by a UEFI application that has any one of the keys in the KEK.
</li></ul>
<p>Finally, in user mode with Secure Boot <i>on</i>, UEFI applications must meet one of the following four requirements to be launched:
</p>
<ul><li> Signed, with signature in db and not in dbx
</li><li> Signed by a key in db and not in dbx
</li><li> Signed by a key in the KEK
</li><li> Unsigned, but a hash of the application is in db and not in dbx
</li></ul>
<p>Note that UEFI applications are not signed by the PK, unless the PK also happens to be in the KEK.
</p><p>Not all UEFI firmwares support Secure Boot, although it is a requirement for Windows 10. Some UEFI firmwares support Secure Boot and do not allow it to be disabled, which poses a problem for independent developers that do not have access to the PK or any of the keys in the KEK, and therefore can't install their own key or application signature or hash to the whitelist database. Independent developers should develop on systems that either do not support Secure Boot or allow Secure Boot to be turned off.
</p>
<h3> <span class="mw-headline" id="How_to_use_UEFI">How to use UEFI</span></h3>
<p>Traditional operating systems like Windows and Linux have an existing software architecture and a large code base to perform system configuration and device discovery. With their sophisticated layers of abstraction they don't directly benefit from UEFI. As a result, their UEFI bootloaders do little but prepare the environment for them to run.
</p><p>An independent developer may find more value in using UEFI to write feature-full UEFI applications, rather than viewing UEFI as a temporary start-up environment to be jettisoned during the boot process. Unlike legacy bootloaders, which typically interact with BIOS only enough to bring up the OS, a UEFI application can implement sophisticated behavior with the help of UEFI. In other words, an independent developer shouldn't be in a rush to leave "UEFI-land".
</p><p>A good starting point is writing a UEFI application that uses the System Table to fetch a memory map, and uses the "File" protocol to read files from FAT-formatted disks. The next step might be to use the System Table to locate ACPI tables.
</p>
<h2> <span class="mw-headline" id="Developing_with_GNU-EFI">Developing with GNU-EFI</span></h2>
<p>GNU-EFI can be used to develop both 32-bit and 64-bit UEFI applications. This section will address 64-bit UEFI applications only, and assumes that the development environment itself is running on an x86_64 system, so that no cross-compiler is needed. For a more thorough walk-through of a proper development environment, see <a href="UEFI_Bare_Bones" title="UEFI Bare Bones">UEFI Bare Bones</a>.
</p><p>GNU-EFI includes four things:
</p>
<ul><li> <b>crt0-efi-x86_64.o</b>: A CRT0 (C runtime initialization code) that provides an entry point that UEFI firmware will call when launching the application, which will in turn call the "efi_main" function that the developer writes.
</li><li> <b>libgnuefi.a</b>: A library containing a single function (<i>_relocate</i>) that is used by the CRT0.
</li><li> <b>elf_x86_64_efi.lds</b>: A linker script used to link UEFI applications.
</li><li> <b>efi.h</b> and other headers: Convenience headers that provide structures, typedefs, and constants improve readability when accessing the System Table and other UEFI resources.
</li><li> <b>libefi.a</b>: A library containing convenience functions like CRC computation, string length calculation, and easy text printing.
</li><li> <b>efilib.h</b>: Header for <i>libefi.a</i>.
</li></ul>
<p>At a bare minimum, a 64-bit UEFI application will need to link against <i>crt0-efi-x86_64.o</i> and <i>libgnuefi.a</i> using the <i>elf_x86_64_efi.lds</i> linker script. Most likely you will want to use the provided headers and the convenience library as well, and this section will assume that going forward.
</p><p>The traditional "Hello, world" UEFI program is shown below.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;efi.h&gt;</span>
<span class="co2">#include &lt;efilib.h&gt;</span>
&#160;
EFI_STATUS
EFIAPI
efi_main <span class="br0">&#40;</span>EFI_HANDLE ImageHandle<span class="sy0">,</span> EFI_SYSTEM_TABLE <span class="sy0">*</span>SystemTable<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
  InitializeLib<span class="br0">&#40;</span>ImageHandle<span class="sy0">,</span> SystemTable<span class="br0">&#41;</span><span class="sy0">;</span>
  Print<span class="br0">&#40;</span>L<span class="st0">&quot;Hello, world!<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">return</span> EFI_SUCCESS<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>A few notes:
</p>
<ul><li> efi.h is included so we can use types like EFI_STATUS, EFI_HANDLE, and EFI_SYSTEM_TABLE.
</li><li> When creating a 32-bit UEFI application, EFIAPI is empty; GCC will compile the "efi_main" function using the standard C calling convention. When creating a 64-bit UEFI application, EFIAPI expands to "__attribute__((ms_abi))" and GCC will compile the "efi_main" function using Microsoft's x64 calling convention, as specified by UEFI. Only functions that will be called directly from UEFI (i.e. main) need to use the UEFI calling convention.
</li><li> "InitializeLib" and "Print" are convenience functions provided by libefi.a with prototypes in efilib.h. "InitializeLib" lets libefi.a store a reference to the ImageHandle and SystemTable provided by BIOS. "Print" uses those stored references to print a string by reaching out to UEFI-provided functions in memory. (Later on we will see how to find and call UEFI-provided functions manually.)
</li></ul>
<p>This program is compiled and linked as below.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ <span class="kw2">gcc</span> main.c                             \
      <span class="re5">-c</span>                                 \
      <span class="re5">-fno-stack-protector</span>               \
      <span class="re5">-fpic</span>                              \
      <span class="re5">-fshort-wchar</span>                      \
      <span class="re5">-mno-red-zone</span>                      \
      <span class="re5">-I</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>gnu-efi<span class="sy0">/</span>headers        \
      <span class="re5">-I</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>gnu-efi<span class="sy0">/</span>headers<span class="sy0">/</span>x86_64 \
      -DEFI_FUNCTION_WRAPPER             \
      <span class="re5">-o</span> main.o
&#160;
$ <span class="kw2">ld</span> main.o                         \
     <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>crt0-efi-x86_64.o     \
     <span class="re5">-nostdlib</span>                      \
     <span class="re5">-znocombreloc</span>                  \
     <span class="re5">-T</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>elf_x86_64_efi.lds \
     <span class="re5">-shared</span>                        \
     <span class="re5">-Bsymbolic</span>                     \
     <span class="re5">-L</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>libs               \
     -l:libgnuefi.a                 \
     -l:libefi.a                    \
     <span class="re5">-o</span> main.so
&#160;
$ objcopy <span class="re5">-j</span> .text                \
          <span class="re5">-j</span> .sdata               \
          <span class="re5">-j</span> .data                \
          <span class="re5">-j</span> .dynamic             \
          <span class="re5">-j</span> .dynsym              \
          <span class="re5">-j</span> .rel                 \
          <span class="re5">-j</span> .rela                \
          <span class="re5">-j</span> .reloc               \
          <span class="re5">--target</span>=efi-app-x86_64 \
          main.so                 \
          main.efi</pre></div></div>
<p>The result of this process is a 44 kB PE executable file <i>main.efi</i>. On a real project you'll probably want to use make or another build tool, and may need to build a cross-compiler.
</p>
<h2> <span class="mw-headline" id="Emulation_with_QEMU_and_OVMF">Emulation with QEMU and OVMF</span></h2>
<p>Any recent version of QEMU with a recent version of OVMF will be sufficient to run a UEFI application. QEMU binaries are available for many platforms, and a binary OVMF image (OVMF.fd) can be found on the <a rel="nofollow" class="external text" href="http://www.tianocore.org/ovmf/">TianoCore</a> website. QEMU (without any boot disk) can be invoked as below. (To prevent recent versions of QEMU from attempting a PXE (network) boot when no boot disk is found, use <code>-net none</code>.
</p><p>The recommended way to use OVMF (for QEMU 1.6 or newer) is with a <code>pflash</code> parameter. The instructions below assume you have an OVMF image split into separate CODE and VARS sections.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ qemu-system-x86_64 <span class="re5">-cpu</span> qemu64 \
  <span class="re5">-drive</span> <span class="re2">if</span>=pflash,<span class="re2">format</span>=raw,<span class="re2">unit</span>=<span class="nu0">0</span>,<span class="re2">file</span>=path_to_OVMF_CODE.fd,<span class="re2">readonly</span>=on \
  <span class="re5">-drive</span> <span class="re2">if</span>=pflash,<span class="re2">format</span>=raw,<span class="re2">unit</span>=<span class="nu0">1</span>,<span class="re2">file</span>=path_to_OVMF_VARS.fd \
  <span class="re5">-net</span> none</pre></div></div>
<p>If you prefer to work on a terminal without a display, or via SSH/telnet, you will want to run QEMU without graphics support, using the <code>-nographic</code> flag.
</p><p>If OVMF does not find a boot disk with a properly named UEFI application (more on this later) it will drop into a UEFI shell.
</p><p><a href="File:OVMF_shell.png" class="image"><img alt="OVMF shell.png" src="images/f/f8/OVMF_shell.png" width="669" height="397" /></a>
</p><p>You can find a list of shell commands <a rel="nofollow" class="external text" href="http://www.sysadminshare.com/2012/01/efi-shell-commands.html">here</a> or you can type <i>help</i> at the shell.
</p>
<h3> <span class="mw-headline" id="Creating_disk_images">Creating disk images</span></h3>
<p>To launch a UEFI application you will need to create a disk image and present it to QEMU. UEFI firmware expects UEFI applications to be stored in a FAT12, FAT16, or FAT32 file system on a <a href="GPT" title="GPT">GPT</a>-partitioned disk. Many firmwares only support FAT32, so that's what you'll want to use. Depending on your platform, there are several different ways to create a disk image containing your UEFI application, but they all start by creating a zeroed disk image file. The minimum FAT32 partition size is 33,548,800 bytes, plus you will need space for the primary and secondary GPT tables, plus some slack space so the partition can be aligned correctly. Throughout these examples we will be creating a 48,000,000 byte (93750 512-byte sectors, or 48 MB) disk image.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="co4">$ </span><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>zero <span class="re2">of</span>=<span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img <span class="re2">bs</span>=<span class="nu0">512</span> <span class="re2">count</span>=<span class="nu0">93750</span></pre></div></div>
<h4> <span class="mw-headline" id="Linux.2C_root_required">Linux, root required</span></h4>
<p>This approach requires root privileges and uses <b>gdisk</b>, <b>losetup</b>, and <b>mkdosfs</b>. First, use gdisk to create a GPT partition table with a single EFI system partition.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ gdisk <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img
GPT fdisk <span class="br0">&#40;</span>gdisk<span class="br0">&#41;</span> version 0.8.10
&#160;
Partition table scan:
  MBR: not present
  BSD: not present
  APM: not present
  GPT: not present
&#160;
Creating new GPT entries.
&#160;
Command <span class="br0">&#40;</span>? <span class="kw1">for</span> <span class="kw3">help</span><span class="br0">&#41;</span>: o
This option deletes all partitions and creates a new protective MBR.
Proceed? <span class="br0">&#40;</span>Y<span class="sy0">/</span>N<span class="br0">&#41;</span>: y
&#160;
Command <span class="br0">&#40;</span>? <span class="kw1">for</span> <span class="kw3">help</span><span class="br0">&#41;</span>: n
Partition number <span class="br0">&#40;</span><span class="nu0">1</span>-<span class="nu0">128</span>, default <span class="nu0">1</span><span class="br0">&#41;</span>: <span class="nu0">1</span>
First sector <span class="br0">&#40;</span><span class="nu0">34</span>-<span class="nu0">93716</span>, default = <span class="nu0">2048</span><span class="br0">&#41;</span> or <span class="br0">&#123;</span>+-<span class="br0">&#125;</span><span class="kw2">size</span><span class="br0">&#123;</span>KMGTP<span class="br0">&#125;</span>: <span class="nu0">2048</span>
Last sector <span class="br0">&#40;</span><span class="nu0">2048</span>-<span class="nu0">93716</span>, default = <span class="nu0">93716</span><span class="br0">&#41;</span> or <span class="br0">&#123;</span>+-<span class="br0">&#125;</span><span class="kw2">size</span><span class="br0">&#123;</span>KMGTP<span class="br0">&#125;</span>: <span class="nu0">93716</span>
Current <span class="kw3">type</span> is <span class="st_h">'Linux filesystem'</span>
Hex code or GUID <span class="br0">&#40;</span>L to show codes, Enter = <span class="nu0">8300</span><span class="br0">&#41;</span>: ef00
Changed <span class="kw3">type</span> of partition to <span class="st_h">'EFI System'</span>
&#160;
Command <span class="br0">&#40;</span>? <span class="kw1">for</span> <span class="kw3">help</span><span class="br0">&#41;</span>: <span class="kw2">w</span>
&#160;
Final checks complete. About to <span class="kw2">write</span> GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS<span class="sy0">!!</span>
&#160;
Do you want to proceed? <span class="br0">&#40;</span>Y<span class="sy0">/</span>N<span class="br0">&#41;</span>: y
OK; writing new GUID partition table <span class="br0">&#40;</span>GPT<span class="br0">&#41;</span> to uefi.img.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot.
The operation has completed successfully.</pre></div></div>
<p>Now you have disk image with <a href="GPT" title="GPT">GUID partition table</a> on it and an unformatted EFI partition starting at sector 2048. Unless you deviated from the commands shown above, the disk image will use 512-byte sectors, so the EFI partition starts at byte 1,048,576 and is 46,934,528 bytes in length. Use losetup to present the partition to Linux on a loopback device.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">losetup <span class="re5">--offset</span> <span class="nu0">1048576</span> <span class="re5">--sizelimit</span> <span class="nu0">46934528</span> <span class="sy0">/</span>dev<span class="sy0">/</span>loop0 <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img</pre></div></div>
<p>(If /dev/loop0 is already in use you will need to select a different loopback device.)
</p><p>Format the partition for FAT32 with mkdosfs.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">mkdosfs <span class="re5">-F</span> <span class="nu0">32</span> <span class="sy0">/</span>dev<span class="sy0">/</span>loop0</pre></div></div>
<p>The partition can now be mounted, so that we can copy files to it. In this example we use the "/mnt" directory, but you could also create a local directory for temporary use.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="kw2">mount</span> <span class="sy0">/</span>dev<span class="sy0">/</span>loop0 <span class="sy0">/</span>mnt</pre></div></div>
<p>Copy any UEFI applications you want to test to the file system.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ <span class="kw2">cp</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>main.efi <span class="sy0">/</span>mnt<span class="sy0">/</span>
$ ...</pre></div></div>
<p>Finally, unmount the partition and free the loopback device.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ <span class="kw2">umount</span> <span class="sy0">/</span>mnt
$ losetup <span class="re5">-d</span> <span class="sy0">/</span>dev<span class="sy0">/</span>loop0</pre></div></div>
<p><i>uefi.img</i> is now a disk image containing primary and secondary GPT tables, containing a single partition of type EFI, containing a FAT32 file system, containing one or more UEFI applications.
</p>
<h4> <span class="mw-headline" id="Linux.2C_root_not_required">Linux, root not required</span></h4>
<p>This approach uses <b>parted</b>, <b>mformat</b>, and <b>mcopy</b> and can be performed with user privileges. First, use parted to create primary and secondary GPT headers, and a single EFI partition spanning the same range as the approach above.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ parted <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img <span class="re5">-s</span> <span class="re5">-a</span> minimal mklabel gpt
$ parted <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img <span class="re5">-s</span> <span class="re5">-a</span> minimal mkpart EFI FAT16 2048s 93716s
$ parted <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img <span class="re5">-s</span> <span class="re5">-a</span> minimal toggle <span class="nu0">1</span> boot</pre></div></div>
<p>Now create a new temporary image file that will contain the EFI partition data and use mformat to format it with FAT16.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>dev<span class="sy0">/</span>zero <span class="re2">of</span>=<span class="sy0">/</span>tmp<span class="sy0">/</span>part.img <span class="re2">bs</span>=<span class="nu0">512</span> <span class="re2">count</span>=<span class="nu0">91669</span>
mformat <span class="re5">-i</span> <span class="sy0">/</span>tmp<span class="sy0">/</span>part.img <span class="re5">-h</span> <span class="nu0">32</span> <span class="re5">-t</span> <span class="nu0">32</span> <span class="re5">-n</span> <span class="nu0">64</span> <span class="re5">-c</span> <span class="nu0">1</span></pre></div></div>
<p>Use mcopy to copy any UEFI applications you want to test to the file system.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ mcopy <span class="re5">-i</span> <span class="sy0">/</span>tmp<span class="sy0">/</span>part.img <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>main.efi&#160;::
$ ...</pre></div></div>
<p>Finally, write the partition image into the main disk image.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="co4">$ </span><span class="kw2">dd</span> <span class="re2">if</span>=<span class="sy0">/</span>tmp<span class="sy0">/</span>part.img <span class="re2">of</span>=<span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img <span class="re2">bs</span>=<span class="nu0">512</span> <span class="re2">count</span>=<span class="nu0">91669</span> <span class="re2">seek</span>=<span class="nu0">2048</span> <span class="re2">conv</span>=notrunc</pre></div></div>
<p><i>uefi.img</i> is now a disk image containing primary and secondary GPT tables, containing a single partition of type EFI, containing a FAT16 file system, containing one or more UEFI applications.
</p>
<h4> <span class="mw-headline" id="FreeBSD.2C_root_required">FreeBSD, root required</span></h4>
<p>This approach requires root privileges and uses <b>mdconfig</b>, <b>gpart</b>, <b>newfs_msdos</b>, and <b>mount_msdosfs</b>. First, create a device node that presents the zeroed disk image as a block device. This will let us work on it using standard partitioning and formatting tools.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ mdconfig <span class="re5">-f</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>uefi.img
md0</pre></div></div>
<p>In this example the new block device is <i>md0</i>. Now create the empty primary and secondary GPT tables on the device.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ gpart create <span class="re5">-s</span> GPT md0
md0 created</pre></div></div>
<p>Now we can add a partition to the disk. We'll specify an "EFI" partition, which just means that GPT will set that partition's GUID to the special "EFI" type. Not all BIOSs require this, and the partition will still be able to be mounted and browsed normally on Linux, FreeBSD, and Windows.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ gpart add <span class="re5">-t</span> efi md0
md0p1 added</pre></div></div>
<p>Next, create a FAT16 file system on the new partition. You can specify various parameters for the file system if you'd like, but it isn't necessary. Ideally you would create a FAT32 partition for best firmware compatibility but FreeBSD seems to create FAT32 partitions that OVMF can't read.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ newfs_msdos <span class="re5">-F</span> <span class="nu0">16</span> md0p1
newfs_msdos: trim <span class="nu0">2</span> sectors to adjust to a multiple of <span class="nu0">9</span>
<span class="sy0">/</span>dev<span class="sy0">/</span>md2p1: <span class="nu0">93552</span> sectors <span class="kw1">in</span> <span class="nu0">11694</span> FAT16 clusters <span class="br0">&#40;</span><span class="nu0">4096</span> bytes<span class="sy0">/</span>cluster<span class="br0">&#41;</span>
<span class="re2">BytesPerSec</span>=<span class="nu0">512</span> <span class="re2">SecPerClust</span>=<span class="nu0">8</span> <span class="re2">ResSectors</span>=<span class="nu0">1</span> <span class="re2">FATs</span>=<span class="nu0">2</span> <span class="re2">RootDirEnts</span>=<span class="nu0">512</span> <span class="re2">Media</span>=0xf0 <span class="re2">FATsecs</span>=<span class="nu0">46</span> <span class="re2">SecPerTrack</span>=<span class="nu0">9</span> <span class="re2">Heads</span>=<span class="nu0">16</span> <span class="re2">HiddenSecs</span>=<span class="nu0">0</span> <span class="re2">HugeSectors</span>=<span class="nu0">93681</span></pre></div></div>
<p>The partition can now be mounted, so that we can copy files to it. In this example we use the <i>/mnt</i> directory, but you could also create a local directory for temporary use.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="co4">$ </span>mount_msdosfs <span class="sy0">/</span>dev<span class="sy0">/</span>md0p1 <span class="sy0">/</span>mnt</pre></div></div>
<p>Copy any UEFI applications you want to test to the file system.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ <span class="kw2">cp</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>main.efi <span class="sy0">/</span>mnt<span class="sy0">/</span>
$ ...</pre></div></div>
<p>Finally, unmount the partition and free the block device.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1">$ <span class="kw2">umount</span> <span class="sy0">/</span>mnt
$ mdconfig <span class="re5">-d</span> <span class="re5">-u</span> md0</pre></div></div>
<p><i>uefi.img</i> is now a disk image containing primary and secondary GPT tables, containing a single partition of type EFI, containing a FAT16 file system, containing one or more UEFI applications.
</p>
<h4> <span class="mw-headline" id="Mac_OS_.28root_not_required.29">Mac OS (root not required)</span></h4>
<p>Mac OS has a single tool (hdiutil) that creates the disk image and copy files at same time.
</p><p>Let's say that you're creating a UEFI boot for x86_64. By definition the file name should be BOOTX64.EFI and this file should be located in the /EFI/BOOT folder.
</p><p>First, let's create a temporary folder that will contains all files and folders required for booting UEFI.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="co4">$ </span><span class="kw2">mkdir</span> <span class="re5">-p</span> diskImage<span class="sy0">/</span>EFI<span class="sy0">/</span>BOOT</pre></div></div>
<p>Secondly, let's copy the boot application to the required location:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="co4">$ </span><span class="kw2">cp</span> bootx64.efi diskImage<span class="sy0">/</span>EFI<span class="sy0">/</span>BOOT<span class="sy0">/</span>BOOTX64.EFI</pre></div></div>
<p>Finally, let's create a disk image partitioned with GPT, formatted with fat32 (-fs fat32), overriding destination file if needed (-ov), define disk size (-size 48m), define volume name (-volname NEWOS), the file format which the disk will be encoded (-format UDTO - the same used for DVDs/CDs) and the source folder containing the files that will be copied to the new disk:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="co4">$ </span>hdiutil create <span class="re5">-fs</span> fat32 <span class="re5">-ov</span> <span class="re5">-size</span> 48m <span class="re5">-volname</span> NEWOS <span class="re5">-format</span> UDTO <span class="re5">-srcfolder</span> diskImage uefi.cdr</pre></div></div>
<p>uefi.cdr should be ready to be used by QEMU.
</p>
<h3> <span class="mw-headline" id="Launching_UEFI_applications">Launching UEFI applications</span></h3>
<p>Once your disk image is ready, you can invoke QEMU as below.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="bash source-bash"><pre class="de1"><span class="co4">$ </span>qemu-system-x86_64 <span class="re5">-cpu</span> qemu64 <span class="re5">-bios</span> <span class="sy0">/</span>path<span class="sy0">/</span>to<span class="sy0">/</span>OVMF.fd <span class="re5">-drive</span> <span class="re2">file</span>=uefi.disk,<span class="re2">if</span>=ide</pre></div></div>
<p>When OVMF drops into the UEFI shell, you will see an additional entry in the "Mapping table", labeled "FS0". This indicates that the firmware detected the disk, discovered the partition, and was able to mount the file system. You can explore the file system by switching to it using the DOS-style syntax "FS0:", as illustrated below.
</p><p><a href="File:OVMF_browse_fs.png" class="image"><img alt="OVMF browse fs.png" src="images/7/7f/OVMF_browse_fs.png" width="669" height="396" /></a>
</p><p>You can launch a UEFI application by entering its name.
</p><p><a href="File:OVMF_run_app.png" class="image"><img alt="OVMF run app.png" src="images/f/fe/OVMF_run_app.png" width="669" height="397" /></a>
</p><p>Notice that the UEFI shell resumed once the application terminated. Of course if this was a proper bootloader it would never resume, but rather launch an OS.
</p><p>Some commercial UEFI firmware provides UEFI shells or the capability to launch user-selected UEFI applications, such as the firmware that ships with the HP EliteBook line of laptops. Most, however, do not expose this functionality to the end-user.
</p>
<h3> <span class="mw-headline" id="Debugging">Debugging</span></h3>
<p>OVMF can be built in debug mode, and it will output logging messages to IO port 0x402.
You can use some flags like the ones below to capture the output.
</p><p><code>-debugcon file:uefi_debug.log -global isa-debugcon.iobase=0x402</code>
</p><p>Note that release builds will not output debug messages, or will have reduced output.
</p><p>See <a href="Debugging_UEFI_applications_with_GDB" title="Debugging UEFI applications with GDB">Debugging UEFI applications with GDB</a>.
</p>
<h2> <span class="mw-headline" id="Running_on_real_hardware">Running on real hardware</span></h2>
<h3> <span class="mw-headline" id="NVRAM_variables">NVRAM variables</span></h3>
<dl><dd><i>Main article:</i> <a href="UEFI_NVRAM" title="UEFI NVRAM">UEFI NVRAM</a>
</dd></dl>
<p>A UEFI firmware will present most of its configuration options through a text or graphical configuration menu, just like a legacy BIOS. Selections made in these menus are stored in the NVRAM chip between reboots. Unlike legacy BIOS, however, the firmware developer has the option to expose some or all of these "NVRAM variables" to the OS and end-user via convenience functions made resident in RAM by the firmware at boot.
</p><p>The Linux <b>efivarfs</b> kernel module will use these functions to list NVRAM variables in the <i>/sys/firmware/efi/efivars</i> file. NVRAM variables can also be dumped from within the UEFI shell itself with the <b>dmpstore</b> command. Device boot order is always accessible via NVRAM variables. The Linux program <b>efibootmgr</b> works specifically with the boot order NVRAM variables. The UEFI shell offers the <b>bcfg</b> command for the same purpose.
</p>
<h3> <span class="mw-headline" id="Bootable_UEFI_applications">Bootable UEFI applications</span></h3>
<p>The boot order NVRAM variables determine where firmware will look for UEFI applications to be launched at boot. Although this can be changed (for example, an OS installer might customize the boot entry for the hard drive to which it was installed) firmware typically looks for a UEFI application named "BOOT.efi" (for 32-bit applications) or "BOOTX64.efi" (for 64-bit applications) stored in the "/EFI/BOOT" path in the boot device's file system. This is the default path and name for OVMF.
</p><p>Unlike a UEFI application launched from the shell, if a bootable UEFI application returns BIOS will continue searching for other boot devices.
</p>
<h3> <span class="mw-headline" id="Exposed_functionality">Exposed functionality</span></h3>
<p>Real PCs vary in the amount of UEFI capability they expose to the user. For example, even a class 3 machine may not make any mention of UEFI in its BIOS configuration and may not offer a UEFI shell. Additionally, some BIOS vendors make their UEFI firmware configuration screens look identical to their legacy BIOS configuration screens. Class 2 machines may present somewhat confusing boot menus and configuration options. For example, one laptop manufacturer includes a configuration option to enable/disable UEFI (i.e. switch between UEFI and CSM behavior), named "OS: Windows 8". Another laptop, if it fails to find a bootable UEFI application on the selected boot device (or if that application returns a status other than EFI_SUCCESS) will fall back to CSM behavior and then complain that the drive has a corrupted MBR. With time, and with the emergence of class 3 machines, clarity of UEFI boot behavior will improve.
</p><p>To make testing on real hardware easier, you can install a bootable UEFI application to the internal hard drive of the system that provides a boot menu, such as <a rel="nofollow" class="external text" href="http://www.rodsbooks.com/refind/">rEFInd</a>. This may also be convenient for multi-boot scenarios.
</p>
<h3> <span class="mw-headline" id="PC_firmware_developers">PC firmware developers</span></h3>
<p>On x86 and x86-64 platforms, the following BIOS developers offer UEFI firmware:
</p>
<ul><li> AMI (Aptio).
</li><li> Phoenix (SecureCore, TrustedCore, AwardCore).
</li><li> Insyde (InsydeH20).
</li></ul>
<h3> <span class="mw-headline" id="Apple_systems">Apple systems</span></h3>
<p>Apple systems implement EFI 1.0, as opposed to UEFI, with the distinction that UEFI applications are loaded from HFS+ file systems instead of FAT12/16/32. Additionally, those UEFI applications must be "blessed" (either directly, or by residing in a blessed directory) to be loaded. Blessing sets flags within the HFS+ file system that Apple's firmware checks before loading an application. The open-source <b>hfsutils</b> package includes support for blessing files within HFS file systems, but not directories nor HFS+.
</p>
<h2> <span class="mw-headline" id="UEFI_applications_in_detail"> UEFI applications in detail </span></h2>
<h3> <span class="mw-headline" id="Binary_Format"> Binary Format </span></h3>
<p>UEFI executables are regular PE32 / PE32+ (Windows x32 / x64) images, with a specific <b>subsystem</b>.
Every UEFI application is basically a windows EXE (or DLL) without symbol tables.
</p>
<table class="wikitable">
<caption> Types of UEFI images
</caption>
<tr>
<th> Type
</th>
<th> Description
</th>
<th> Subsystem
</th></tr>
<tr>
<td> Applications </td>
<td> OS loaders and other utility programs. </td>
<td> 10
</td></tr>
<tr>
<td> Boot service driver </td>
<td> Drivers used by the firmware when booting (e.g. disk drivers, network drivers). </td>
<td> 11
</td></tr>
<tr>
<td> Runtime driver </td>
<td> Drivers which may stay loaded even after the OS loads and exits the boot services. </td>
<td> 12
</td></tr></table>
<p>UEFI images must also specify the type of machine code they contain. A UEFI loader will refuse to boot an incompatible image.
</p>
<table class="wikitable">
<caption> Types of machines
</caption>
<tr>
<th> Name / arch
</th>
<th> Value
</th></tr>
<tr>
<td>x86</td>
<td>0x014c
</td></tr>
<tr>
<td>x86_64</td>
<td>0x8664
</td></tr>
<tr>
<td>Itanium x64</td>
<td>0x0200
</td></tr>
<tr>
<td>UEFI Byte Code</td>
<td>0x0EBC
</td></tr>
<tr>
<td>ARM<sup>1</sup></td>
<td>0x01C2
</td></tr>
<tr>
<td>AArch (ARM x64)</td>
<td>0xAA64
</td></tr>
<tr>
<td>RISC-V x32</td>
<td>0x5032
</td></tr>
<tr>
<td>RISC-V x64</td>
<td>0x5064
</td></tr>
<tr>
<td>RISC-V x128</td>
<td>0x5128
</td></tr></table>
<p>[1] ARM means you can use Thumb / Thumb 2 instructions, but UEFI interfaces are in ARM mode.
</p>
<h4> <span class="mw-headline" id="Initialization"> Initialization </span></h4>
<p>Applications must either load an OS and exit boot services, or return from the main function (in which case the boot loader will look for the next app to load).
</p><p>Drivers must initialize and then return 0 on success, or an error code. A computer might fail too boot if a required driver fails to load.
</p>
<h4> <span class="mw-headline" id="Memory"> Memory </span></h4>
<p>The memory map returned by UEFI will mark the memory areas which drivers use.
</p><p>Once your OS loader finished, your kernel is allowed to reuse the memory where the boot loader was loaded.
</p><p>The memory types are <code>Efi{Loader/BootServices/RuntimeServices}{Code/Data}</code>.
</p><p>After exiting the boot services, you may reuse whatever non-read-only memory the boot drivers used.
</p><p>However, memory used by the runtime drivers must <b>never</b> be touched - the runtime drivers stay active and loaded for as long as the computer runs.
</p><p>TODO - I'd like to show a breakdown of a PE file containing a UEFI application here.
</p>
<h3> <span class="mw-headline" id="Calling_Conventions"> Calling Conventions </span></h3>
<p>UEFI specifies the following calling conventions:
</p>
<ul><li> <b>cdecl</b> for x86 UEFI functions
</li><li> <b>Microsoft's 64-bit calling convention</b> for x86-64 UEFI functions
</li><li> <b>SMC</b> for ARM UEFI functions
</li></ul>
<p>This has two impacts on UEFI application developers:
</p>
<ul><li> A UEFI application's main entry point must expect to be called with the corresponding calling convention.
</li><li> Any UEFI-provided functions that a UEFI application calls must be called with the corresponding calling convention.
</li></ul>
<p>Note that functions strictly internal to the application can use whatever calling convention the developer chooses.
</p>
<h4> <span class="mw-headline" id="GNU-EFI_and_GCC"> GNU-EFI and GCC </span></h4>
<p>cdecl is the standard calling convention used by GCC, so no special attributes or modifiers are needed for writing the main entry point or calling UEFI functions in an x86 UEFI application developed with GNU-EFI. For x86-64, however, the entry point function must be declared with the "___attribute___((ms_abi))" modifier and all calls to UEFI-provided functions must be made through the "uefi_call_wrapper" thunk. This thunk is called with cdecl, but then translates to the Microsoft x86-64 calling convention before calling the requested UEFI function. This is necessary because older releases of GCC do not support specifying calling conventions for function pointers.
</p><p>For developer convenience, GNU-EFI provides the "EFIAPI" macro, which expands to "cdecl" when targeting x86 and "__attribute__(ms_abi))" when targeting x86-64. Additionally, the "uefi_call_wrapper" thunk will simply pass the call through on x86. This allows the same source code to target x86 and x86-64. For example, the following main function will compile with the correct calling convention on both x86 and x86-64 and the call through the "uefi_call_wrapper" thunk will select the correct calling convention to use when calling the UEFI function (in this case, printing a string).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1">EFI_STATUS EFIAPI efi_main<span class="br0">&#40;</span>EFI_HANDLE ImageHandle<span class="sy0">,</span> EFI_SYSTEM_TABLE <span class="sy0">*</span>SystemTable<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
  EFI_STATUS status <span class="sy0">=</span> uefi_call_wrapper<span class="br0">&#40;</span>SystemTable<span class="sy0">-&gt;</span>ConOut<span class="sy0">-&gt;</span>OutputString<span class="sy0">,</span>
                                        <span class="nu0">2</span><span class="sy0">,</span>
                                        SystemTable<span class="sy0">-&gt;</span>ConOut<span class="sy0">,</span>
                                        L<span class="st0">&quot;Hello, World!<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">return</span> status<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<h3> <span class="mw-headline" id="Language_binding"> Language binding </span></h3>
<p>UEFI applications are typically written in C, although bindings could be written for any other language that compiles to machine code. Assembly is also an option; a <a href="Uefi.inc" title="Uefi.inc">uefi.inc</a> is available for <a href="FASM" title="FASM">FASM</a> that allows UEFI applications to be written as below.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="asm source-asm"><pre class="de1">format pe64 dll efi
entry main
&#160;
section <span class="st0">'.text'</span> <span class="kw4">code</span> executable readable
&#160;
<span class="kw4">include</span> <span class="st0">'uefi.inc'</span>
&#160;
main<span class="sy0">:</span>
    <span class="co1">; initialize UEFI library</span>
    InitializeLib
    <span class="kw1">jc</span> <span class="kw5">@f</span>
&#160;
    <span class="co1">; call uefi function to print to screen</span>
    uefi_call_wrapper ConOut<span class="sy0">,</span> OutputString<span class="sy0">,</span> ConOut<span class="sy0">,</span> _hello
&#160;
@@<span class="sy0">:</span> <span class="kw1">mov</span> <span class="kw3">eax</span><span class="sy0">,</span> EFI_SUCCESS
    <span class="kw1">retn</span>
&#160;
section <span class="st0">'.data'</span> <span class="kw4">data</span> readable writeable
&#160;
_hello                                  du <span class="st0">'Hello World'</span><span class="sy0">,</span><span class="nu0">13</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">0</span>
&#160;
section <span class="st0">'.reloc'</span> fixups <span class="kw4">data</span> discardable</pre></div></div>
<p>As a UEFI application contains normal x86 or x86-64 machine code, inline assembly is also an option in compilers that support it.
</p>
<h3> <span class="mw-headline" id="EFI_Byte_Code"> EFI Byte Code</span></h3>
<p>UEFI also includes a virtual machine specification based on a byte code format called EFI Byte Code (EBC), which can be used to write platform-independent device drivers, but not UEFI applications. As of 2015 there has been limited use of EBC.
</p>
<h2> <span class="mw-headline" id="Common_Problems"> Common Problems </span></h2>
<h3> <span class="mw-headline" id="My_UEFI_application_hangs.2Fresets_after_about_5_minutes"> My UEFI application hangs/resets after about 5 minutes </span></h3>
When control is handed to your UEFI application by firmware, it sets a watchdog timer for 5 minutes, after which the firmware is reinvoked as it assumes your application has hung.  The firmware in this case will normally try to reset the system (although the OVMF firmware in VirtualBox simply causes the screen to go black and hang).  To counteract this, you are required to refresh the watchdog timer before it times out.  Alternatively, you can disable it completely with code like <div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1">SystemTable<span class="sy0">-&gt;</span>BootServices<span class="sy0">-&gt;</span>SetWatchdogTimer<span class="br0">&#40;</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> NULL<span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>Obviously this is not a problem for most bootloaders, but can cause an issue if you have an interactive loader which waits for user input.  Also note that you are required to disable the watchdog timer if you exit back to the firmware.
<h3> <span class="mw-headline" id="My_bootloader_hangs_if_I_use_user_defined_EFI_MEMORY_TYPE_values"> My bootloader hangs if I use user defined EFI_MEMORY_TYPE values </span></h3>
<p>For the memory management functions in EFI, an OS is meant to be able to use "memory type" values above 0x80000000 for its own purposes. In the OVFM EFI firmware release "r11337" (for Qemu, etc) there is a bug where the firmware assumes the memory type is within the range of values defined for EFI's own use, and uses the memory type as an array index. The end result is an "array index out of bounds" bug; where the higher memory type values (e.g. perfectly legal values above 0x80000000) cause the 64-bit version of the firmware to crash (page fault), and cause incorrect "attribute" values to be reported by the 32-bit version of the firmware. This same bug is also present in whatever version of the EFI firmware VirtualBox uses (which looks like an older version of OVFM); and I suspect (but don't know) that the bug may be present in a wide variety of firmware that was derived from the tianocore project (not just OVFM). <a href="http://wiki.osdev.org/index.php?title=User:Brendan&amp;action=edit&amp;redlink=1" class="new" title="User:Brendan (page does not exist)">Brendan</a> 15:30, 29 July 2011 (UTC)
This issue shows in AMI BIOSes at least to 2015, maybe up to the present day --<a href="http://wiki.osdev.org/User:Bellezzasolo" title="User:Bellezzasolo">Bellezzasolo</a> 11:41, 19 August 2017 (CDT)
</p>
<h2> <span class="mw-headline" id="See_also"> See also </span></h2>
<h3> <span class="mw-headline" id="OSDEV"> OSDEV </span></h3>
<ul><li> <a href="UEFI_Bare_Bones" title="UEFI Bare Bones">UEFI Bare Bones</a>
</li><li> <a href="PE" title="PE">PE</a> file format
</li><li> <a href="http://wiki.osdev.org/index.php?title=TianoCore&amp;action=edit&amp;redlink=1" class="new" title="TianoCore (page does not exist)">TianoCore</a>
</li></ul>
<h3> <span class="mw-headline" id="Wikipedia"> Wikipedia </span></h3>
<ul><li> <a href="http://wikipedia.org/wiki/Extensible_Firmware_Interface" class="extiw" title="wikipedia:Extensible Firmware Interface">EFI</a>
</li></ul>
<h3> <span class="mw-headline" id="External_Links"> External Links </span></h3>
<ul><li> <a rel="nofollow" class="external text" href="http://www.uefi.org/specifications">UEFI specifications et al.</a>
</li><li> <a rel="nofollow" class="external text" href="http://www.tianocore.org/">Intel TianoCore EDK2</a>
</li><li> <a rel="nofollow" class="external text" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF firmware images</a> for use with <a href="QEMU" title="QEMU">QEMU</a>
</li><li> <a rel="nofollow" class="external text" href="http://wiki.phoenix.com/">Phoenix UEFI Wiki</a>
</li><li> <a rel="nofollow" class="external text" href="http://x86asm.net/articles/others/index.html">Several articles about UEFI</a>
</li><li> <a rel="nofollow" class="external text" href="https://www.microsoft.com/en-us/download/details.aspx?id=19509">PE specification covering the (U)EFI binary format</a>
</li><li> <a rel="nofollow" class="external text" href="https://uefi.blogspot.com/">Blog about UEFI, with bits about UEFI development</a>
</li><li> <a rel="nofollow" class="external text" href="http://internshipatdell.wikispaces.com/file/view/How+to+build+an+UEFI+application.pptx">Presentation guiding through simple UEFI application setup</a>
</li><li> <a rel="nofollow" class="external text" href="http://www.uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf">Presentation giving an overview of windows uefi booting</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 524/1000000
Post-expand include size: 33/2097152 bytes
Template argument size: 10/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2924-0!*!0!!en!2!* and timestamp 20180121040118 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://wiki.osdev.org/index.php?title=UEFI&amp;oldid=22092">http://wiki.osdev.org/index.php?title=UEFI&amp;oldid=22092</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="http://wiki.osdev.org/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="Category:X86" title="Category:X86">X86</a></li><li><a href="Category:X86-64" title="Category:X86-64">X86-64</a></li><li><a href="Category:IA-64" title="Category:IA-64">IA-64</a></li><li><a href="Category:ARM" title="Category:ARM">ARM</a></li><li><a href="Category:Firmware" title="Category:Firmware">Firmware</a></li><li><a href="Category:UEFI" title="Category:UEFI">UEFI</a></li></ul></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="http://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=UEFI" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="UEFI"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk"><span><a href="Talk:UEFI"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="EFI#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="UEFI" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://wiki.osdev.org/index.php?title=UEFI&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.osdev.org/index.php?title=UEFI&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="EFI#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="http://wiki.osdev.org/index.php" id="searchform">
		<input type='hidden' name="title" value="Special:Search"/>
				<input type="search" name="search" title="Search OSDev Wiki [f]" accesskey="f" id="searchInput" />		<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />		<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/skins/common/images/osdev.png);" href="Main_Page"  title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id='p-navigation'>
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="/Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
			<li id="n-portal"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things">Forums</a></li>
			<li id="n-FAQ"><a href="/Category:FAQ">FAQ</a></li>
			<li id="n-OS-Projects"><a href="/Projects">OS Projects</a></li>
			<li id="n-randompage"><a href="/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- about -->
<div class="portal" id='p-about'>
	<h5>About</h5>
	<div class="body">
		<ul>
			<li id="n-This-site"><a href="/OSDevWiki:About">This site</a></li>
			<li id="n-Joining"><a href="/OSDevWiki:Joining">Joining</a></li>
			<li id="n-Editing-help"><a href="/OSDevWiki:Editing">Editing help</a></li>
			<li id="n-recentchanges"><a href="/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
		</ul>
	</div>
</div>

<!-- /about -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id='p-tb'>
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/Special:WhatLinksHere/UEFI" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/Special:RecentChangesLinked/UEFI" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li><a href="/index.php?title=UEFI&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="/index.php?title=UEFI&amp;oldid=22092" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->
<div class="portal" id='p-lang'>
	<h5>In other languages</h5>
	<div class="body">
		<ul>
			<li class="interwiki-de"><a href="http://www.lowlevel.eu/wiki/Unified_Extensible_Firmware_Interface" title="Unified Extensible Firmware Interface">Deutsch</a></li>
		</ul>
	</div>
</div>

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 16 January 2018, at 08:45.</li>
											<li id="footer-info-viewcount">This page has been accessed 163,406 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/OSDev_Wiki:Privacy_policy" title="OSDev Wiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/OSDev_Wiki:About" title="OSDev Wiki:About">About OSDev Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="/OSDev_Wiki:General_disclaimer" title="OSDev Wiki:General disclaimer">Disclaimerskins/common/images/osdev.png);" href="/Main_Page"  title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id='p-navigation'>
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
			<li id="n-portal"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things">Forums</a></li>
			<li id="n-FAQ"><a href="Category:FAQ">FAQ</a></li>
			<li id="n-OS-Projects"><a href="Projects">OS Projects</a></li>
			<li id="n-randompage"><a href="http://wiki.osdev.org/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- about -->
<div class="portal" id='p-about'>
	<h5>About</h5>
	<div class="body">
		<ul>
			<li id="n-This-site"><a href="OSDevWiki:About">This site</a></li>
			<li id="n-Joining"><a href="OSDevWiki:Joining">Joining</a></li>
			<li id="n-Editing-help"><a href="OSDevWiki:Editing">Editing help</a></li>
			<li id="n-recentchanges"><a href="http://wiki.osdev.org/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
		</ul>
	</div>
</div>

<!-- /about -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id='p-tb'>
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.osdev.org/Special:WhatLinksHere/UEFI" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.osdev.org/Special:RecentChangesLinked/UEFI" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.osdev.org/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li><a href="http://wiki.osdev.org/index.php?title=UEFI&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="http://wiki.osdev.org/index.php?title=UEFI&amp;oldid=22092" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->
<div class="portal" id='p-lang'>
	<h5>In other languages</h5>
	<div class="body">
		<ul>
			<li class="interwiki-de"><a href="http://www.lowlevel.eu/wiki/Unified_Extensible_Firmware_Interface" title="Unified Extensible Firmware Interface">Deutsch</a></li>
		</ul>
	</div>
</div>

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 16 January 2018, at 08:45.</li>
											<li id="footer-info-viewcount">This page has been accessed 163,406 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="OSDev_Wiki:Privacy_policy" title="OSDev Wiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="OSDev_Wiki:About" title="OSDev Wiki:About">About OSDev Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="OSDev_Wiki:General_disclaimer" title="OSDev Wiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<script src="http://wiki.osdev.org/load.php?debug=false&amp;lang=en&amp;modules=skins.vector&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script>
<script src="http://wiki.osdev.org/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,
	"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: wikidb:resourceloader:filter:minify-js:4:19a4b18a9ac79a6b8c60b24af4668814 */
}
</script><!-- Served in 0.038 secs. -->
	</body>
</html>
